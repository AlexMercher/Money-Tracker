import 'package:flutter_test/flutter_test.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:moneytrack/services/category_service.dart';

void main() {
  group('Category Service Tests', () {
    setUp(() async {
      // Reset SharedPreferences before each test
      SharedPreferences.setMockInitialValues({});
      await CategoryService.clearAll();
    });

    group('Note Validation - Must NOT learn junk', () {
      test('should NOT learn from empty note', () {
        expect(CategoryService.isValidForLearning(''), false);
        expect(CategoryService.normalizeNote(''), null);
      });

      test('should NOT learn from "no note"', () {
        expect(CategoryService.isValidForLearning('no note'), false);
        expect(CategoryService.normalizeNote('no note'), null);
      });

      test('should NOT learn from "none"', () {
        expect(CategoryService.isValidForLearning('none'), false);
        expect(CategoryService.normalizeNote('none'), null);
      });

      test('should NOT learn from single dot', () {
        expect(CategoryService.isValidForLearning('.'), false);
        expect(CategoryService.normalizeNote('.'), null);
      });

      test('should NOT learn from dashes', () {
        expect(CategoryService.isValidForLearning('--'), false);
        expect(CategoryService.normalizeNote('--'), null);
        expect(CategoryService.isValidForLearning('-'), false);
      });

      test('should NOT learn from whitespace only', () {
        expect(CategoryService.isValidForLearning('   '), false);
        expect(CategoryService.normalizeNote('   '), null);
      });

      test('should NOT learn from short notes (< 3 chars)', () {
        expect(CategoryService.isValidForLearning('ab'), false);
        expect(CategoryService.normalizeNote('ab'), null);
        expect(CategoryService.isValidForLearning('x'), false);
      });

      test('should NOT learn from myshare pattern', () {
        expect(CategoryService.isValidForLearning('Food (my share)'), false);
        expect(CategoryService.isValidForLearning('Pizza (myshare)'), false);
        expect(CategoryService.isValidForLearning('YOU(myshare)'), false);
      });

      test('should NOT learn from system-generated strings', () {
        // CRITICAL: These are auto-generated by the app, NOT user input
        expect(CategoryService.isValidForLearning('Split Transaction'), false);
        expect(CategoryService.isValidForLearning('split transaction'), false);
        expect(CategoryService.isValidForLearning('SPLIT TRANSACTION'), false);
        expect(CategoryService.isValidForLearning('Single Transaction'), false);
        expect(CategoryService.isValidForLearning('single transaction'), false);
        expect(CategoryService.isValidForLearning('Transaction'), false);
        expect(CategoryService.isValidForLearning('My Share'), false);
        expect(CategoryService.isValidForLearning('You (My Share)'), false);
        // System strings with suffixes should also be blocked
        expect(CategoryService.isValidForLearning('Split transaction (My Share)'), false);
        expect(CategoryService.isValidForLearning('Split Transaction for dinner'), false);
      });

      test('should NOT learn from punctuation only', () {
        expect(CategoryService.isValidForLearning('...'), false);
        expect(CategoryService.isValidForLearning('!!!'), false);
        expect(CategoryService.isValidForLearning('???'), false);
      });

      test('should NOT learn from numbers only', () {
        expect(CategoryService.isValidForLearning('123'), false);
        expect(CategoryService.isValidForLearning('100'), false);
      });

      test('should NOT learn from n/a variants', () {
        expect(CategoryService.isValidForLearning('n/a'), false);
        expect(CategoryService.isValidForLearning('na'), false);
        expect(CategoryService.isValidForLearning('nil'), false);
      });
    });

    group('Note Validation - SHOULD learn valid notes', () {
      test('should learn from valid category name', () {
        expect(CategoryService.isValidForLearning('Groceries'), true);
        expect(CategoryService.normalizeNote('Groceries'), 'groceries');
      });

      test('should learn from multi-word category', () {
        expect(CategoryService.isValidForLearning('Grocery Shopping'), true);
        expect(CategoryService.normalizeNote('Grocery Shopping'), 'grocery shopping');
      });

      test('should learn from food category', () {
        expect(CategoryService.isValidForLearning('Food'), true);
        expect(CategoryService.normalizeNote('Food'), 'food');
      });

      test('should learn from transport category', () {
        expect(CategoryService.isValidForLearning('Transport'), true);
        expect(CategoryService.normalizeNote('Transport'), 'transport');
      });
    });

    group('Case-insensitive Normalization', () {
      test('should normalize to lowercase', () {
        expect(CategoryService.normalizeNote('GROCERIES'), 'groceries');
        expect(CategoryService.normalizeNote('Groceries'), 'groceries');
        expect(CategoryService.normalizeNote('groceries'), 'groceries');
      });

      test('should normalize mixed case', () {
        expect(CategoryService.normalizeNote('GrOcErIeS'), 'groceries');
      });

      test('should trim whitespace', () {
        expect(CategoryService.normalizeNote('  Groceries  '), 'groceries');
        expect(CategoryService.normalizeNote('Groceries '), 'groceries');
        expect(CategoryService.normalizeNote(' Groceries'), 'groceries');
      });

      test('should remove leading/trailing punctuation', () {
        expect(CategoryService.normalizeNote('Groceries.'), 'groceries');
        expect(CategoryService.normalizeNote('.Groceries'), 'groceries');
        expect(CategoryService.normalizeNote('...Groceries...'), 'groceries');
      });
    });

    group('Learning Notes (Class A)', () {
      test('should learn valid note and increment frequency', () async {
        await CategoryService.learnCategory('Groceries');
        
        final freq = await CategoryService.getFrequency('groceries');
        expect(freq, 1);
        
        await CategoryService.learnCategory('Groceries');
        final freq2 = await CategoryService.getFrequency('groceries');
        expect(freq2, 2);
      });

      test('should NOT learn invalid note', () async {
        await CategoryService.learnCategory('');
        await CategoryService.learnCategory('no note');
        await CategoryService.learnCategory('.');
        
        final all = await CategoryService.getAllNotes();
        expect(all, isEmpty);
      });

      test('should store multiple notes', () async {
        await CategoryService.learnCategory('Groceries');
        await CategoryService.learnCategory('Food');
        await CategoryService.learnCategory('Transport');
        
        final all = await CategoryService.getAllNotes();
        expect(all.length, 3);
      });
    });

    group('Trie-based Prefix Suggestions', () {
      test('should return suggestions based on prefix via Trie', () async {
        await CategoryService.learnCategory('Groceries');
        await CategoryService.learnCategory('Grocery Store');
        await CategoryService.learnCategory('Food');
        
        final suggestions = await CategoryService.getSuggestions('gro');
        expect(suggestions.length, 2);
        expect(suggestions.any((s) => s.toLowerCase() == 'groceries'), true);
        expect(suggestions.any((s) => s.toLowerCase() == 'grocery store'), true);
      });

      test('should return empty for no match in Trie', () async {
        await CategoryService.learnCategory('Groceries');
        
        final suggestions = await CategoryService.getSuggestions('xyz');
        expect(suggestions, isEmpty);
      });

      test('Trie should be case-insensitive', () async {
        await CategoryService.learnCategory('Groceries');
        
        final suggestions1 = await CategoryService.getSuggestions('gro');
        final suggestions2 = await CategoryService.getSuggestions('GRO');
        final suggestions3 = await CategoryService.getSuggestions('Gro');
        
        expect(suggestions1.length, 1);
        expect(suggestions2.length, 1);
        expect(suggestions3.length, 1);
      });

      test('should return empty for empty prefix', () async {
        await CategoryService.learnCategory('Groceries');
        
        final suggestions = await CategoryService.getSuggestions('');
        expect(suggestions, isEmpty);
      });

      test('Trie should order by frequency', () async {
        await CategoryService.learnCategory('Groceries');
        await CategoryService.learnCategory('Games');
        await CategoryService.learnCategory('Games');
        await CategoryService.learnCategory('Games');
        
        final suggestions = await CategoryService.getSuggestions('g');
        expect(suggestions.first.toLowerCase(), 'games'); // More frequent
      });

      test('Trie handles single character prefix', () async {
        await CategoryService.learnCategory('Apples');
        await CategoryService.learnCategory('Bananas');
        await CategoryService.learnCategory('Avocado');
        
        final suggestions = await CategoryService.getSuggestions('a');
        // Now returns all notes containing 'a', sorted by relevance:
        // Tier 1 (prefix): Apples, Avocado
        // Tier 3 (substring): Bananas
        expect(suggestions.length, 3);
        // Prefix matches come first, alphabetically
        expect(suggestions[0].toLowerCase(), 'apples');
        expect(suggestions[1].toLowerCase(), 'avocado');
        // Substring match comes last
        expect(suggestions[2].toLowerCase(), 'bananas');
      });

      test('Trie handles long prefix', () async {
        await CategoryService.learnCategory('Grocery Shopping');
        
        final suggestions = await CategoryService.getSuggestions('grocery shop');
        expect(suggestions.length, 1);
        expect(suggestions.first.toLowerCase(), 'grocery shopping');
      });
    });

    group('Persistence', () {
      test('should persist across service calls', () async {
        await CategoryService.learnCategory('Groceries');
        await CategoryService.learnCategory('Food');
        
        // Simulate app restart by getting notes again
        final notes = await CategoryService.getAllNotes();
        expect(notes.length, 2);
      });

      test('should persist frequency correctly', () async {
        await CategoryService.learnCategory('Groceries');
        await CategoryService.learnCategory('Groceries');
        await CategoryService.learnCategory('Groceries');
        
        final freq = await CategoryService.getFrequency('groceries');
        expect(freq, 3);
      });

      test('Trie should persist after clear and re-learn', () async {
        await CategoryService.learnCategory('Groceries');
        await CategoryService.clearAll();
        await CategoryService.learnCategory('Food');
        
        final suggestions = await CategoryService.getSuggestions('gro');
        expect(suggestions, isEmpty);
        
        final foodSuggestions = await CategoryService.getSuggestions('foo');
        expect(foodSuggestions.length, 1);
      });
    });

    group('Category Rename (Class B)', () {
      test('should rename category successfully', () async {
        await CategoryService.createCategory('Shopping');
        
        final result = await CategoryService.renameCategory('shopping', 'food shopping');
        expect(result, true);
        
        final categories = await CategoryService.getAllCategories();
        expect(categories.length, 1);
        expect(categories.first.toLowerCase(), 'food shopping');
      });

      test('rename should update note assignments', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.learnNote('Groceries');
        await CategoryService.assignNoteToCategory('groceries', 'shopping');
        
        await CategoryService.renameCategory('shopping', 'food shopping');
        
        final category = await CategoryService.getCategoryForNote('groceries');
        expect(category?.toLowerCase(), 'food shopping');
      });

      test('should fail to rename non-existent category', () async {
        final result = await CategoryService.renameCategory('nonexistent', 'new name');
        expect(result, false);
      });

      test('should fail to rename to existing category name', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.createCategory('Entertainment');
        
        final result = await CategoryService.renameCategory('shopping', 'entertainment');
        expect(result, false);
      });

      test('rename to same name should succeed', () async {
        await CategoryService.createCategory('Shopping');
        final result = await CategoryService.renameCategory('shopping', 'shopping');
        expect(result, true);
      });
    });

    group('Class B Category Management', () {
      test('should create category successfully', () async {
        final result = await CategoryService.createCategory('Shopping');
        expect(result, true);
        
        final categories = await CategoryService.getAllCategories();
        expect(categories.length, 1);
        expect(categories.first.toLowerCase(), 'shopping');
      });

      test('should not create duplicate category', () async {
        await CategoryService.createCategory('Shopping');
        final result = await CategoryService.createCategory('shopping');
        expect(result, false);
        
        final categories = await CategoryService.getAllCategories();
        expect(categories.length, 1);
      });

      test('should delete category successfully', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.createCategory('Entertainment');
        
        final result = await CategoryService.deleteCategory('shopping');
        expect(result, true);
        
        final categories = await CategoryService.getAllCategories();
        expect(categories.length, 1);
        expect(categories.first.toLowerCase(), 'entertainment');
      });

      test('should fail to delete non-existent category', () async {
        final result = await CategoryService.deleteCategory('nonexistent');
        expect(result, false);
      });

      test('delete category should release notes to independent', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.learnNote('Groceries');
        await CategoryService.assignNoteToCategory('groceries', 'shopping');
        
        // Verify assignment
        final categoryBefore = await CategoryService.getCategoryForNote('groceries');
        expect(categoryBefore?.toLowerCase(), 'shopping');
        
        // Delete category
        await CategoryService.deleteCategory('shopping');
        
        // Note should now be independent
        final categoryAfter = await CategoryService.getCategoryForNote('groceries');
        expect(categoryAfter, isNull);
      });
    });

    group('Note Assignment (Class A → Class B)', () {
      test('should assign note to category', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.learnNote('Groceries');
        
        final result = await CategoryService.assignNoteToCategory('groceries', 'shopping');
        expect(result, true);
        
        final category = await CategoryService.getCategoryForNote('groceries');
        expect(category?.toLowerCase(), 'shopping');
      });

      test('should fail to assign to non-existent category', () async {
        await CategoryService.learnNote('Groceries');
        
        final result = await CategoryService.assignNoteToCategory('groceries', 'nonexistent');
        expect(result, false);
      });

      test('should remove note from category', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.learnNote('Groceries');
        await CategoryService.assignNoteToCategory('groceries', 'shopping');
        
        final result = await CategoryService.removeNoteFromCategory('groceries');
        expect(result, true);
        
        final category = await CategoryService.getCategoryForNote('groceries');
        expect(category, isNull);
      });

      test('should get independent notes', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.learnNote('Groceries');
        await CategoryService.learnNote('Coffee');
        await CategoryService.learnNote('Books');
        
        await CategoryService.assignNoteToCategory('groceries', 'shopping');
        
        final independent = await CategoryService.getIndependentNotes();
        expect(independent.length, 2);
        expect(independent.any((n) => n.normalizedName == 'coffee'), true);
        expect(independent.any((n) => n.normalizedName == 'books'), true);
        expect(independent.any((n) => n.normalizedName == 'groceries'), false);
      });

      test('should get notes in category', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.learnNote('Groceries');
        await CategoryService.learnNote('Clothes');
        await CategoryService.learnNote('Coffee');
        
        await CategoryService.assignNoteToCategory('groceries', 'shopping');
        await CategoryService.assignNoteToCategory('clothes', 'shopping');
        
        final notesInShopping = await CategoryService.getNotesInCategory('shopping');
        expect(notesInShopping.length, 2);
        expect(notesInShopping.any((n) => n.toLowerCase() == 'groceries'), true);
        expect(notesInShopping.any((n) => n.toLowerCase() == 'clothes'), true);
      });

      test('note can only belong to one category at a time', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.createCategory('Food');
        await CategoryService.learnNote('Groceries');
        
        await CategoryService.assignNoteToCategory('groceries', 'shopping');
        await CategoryService.assignNoteToCategory('groceries', 'food');
        
        // Should now be in Food, not Shopping
        final category = await CategoryService.getCategoryForNote('groceries');
        expect(category?.toLowerCase(), 'food');
        
        final inShopping = await CategoryService.getNotesInCategory('shopping');
        expect(inShopping, isEmpty);
        
        final inFood = await CategoryService.getNotesInCategory('food');
        expect(inFood.length, 1);
      });

      test('getNoteToDisplayLabelMap returns correct mapping', () async {
        await CategoryService.createCategory('Shopping');
        await CategoryService.learnNote('Groceries');
        await CategoryService.learnNote('Coffee');
        
        await CategoryService.assignNoteToCategory('groceries', 'shopping');
        
        final mapping = await CategoryService.getNoteToDisplayLabelMap();
        expect(mapping['groceries'], 'shopping');
        expect(mapping['coffee'], isNull);
      });
    });

    group('Migration', () {
      test('should migrate valid notes only', () async {
        final transactions = [
          {'note': 'Groceries'},
          {'note': 'Food'},
          {'note': ''},          // Invalid - empty
          {'note': 'no note'},   // Invalid - placeholder
          {'note': '.'},         // Invalid - punctuation
          {'note': 'Transport'},
        ];
        
        final count = await CategoryService.migrateExistingTransactions(() => transactions);
        
        expect(count, 3); // Only Groceries, Food, Transport
        
        final all = await CategoryService.getAllNotes();
        expect(all.length, 3);
      });

      test('migration should be idempotent', () async {
        final transactions = [
          {'note': 'Groceries'},
          {'note': 'Food'},
        ];
        
        final count1 = await CategoryService.migrateExistingTransactions(() => transactions);
        expect(count1, 2);
        
        // Second call should return -1 (already migrated)
        final count2 = await CategoryService.migrateExistingTransactions(() => transactions);
        expect(count2, -1);
        
        // Notes should still be 2
        final all = await CategoryService.getAllNotes();
        expect(all.length, 2);
      });

      test('migration should skip invalid notes', () async {
        final transactions = [
          {'note': 'no note'},
          {'note': 'none'},
          {'note': '--'},
          {'note': 'n/a'},
          {'note': '   '},
          {'note': 'YOU(myshare)'},
        ];
        
        final count = await CategoryService.migrateExistingTransactions(() => transactions);
        expect(count, 0);
        
        final all = await CategoryService.getAllNotes();
        expect(all, isEmpty);
      });

      test('migration flag can be reset', () async {
        final transactions = [{'note': 'Groceries'}];
        
        await CategoryService.migrateExistingTransactions(() => transactions);
        expect(await CategoryService.isMigrationDone(), true);
        
        await CategoryService.resetMigrationFlag();
        expect(await CategoryService.isMigrationDone(), false);
      });

      test('migration handles null notes gracefully', () async {
        final transactions = [
          {'note': null},
          {'note': 'Valid Category'},
        ];
        
        final count = await CategoryService.migrateExistingTransactions(() => transactions);
        expect(count, 1);
      });
    });

    group('Self-expense Only - Conceptual', () {
      test('service learns from any valid note source', () async {
        // The Trie learns from all notes for suggestion purposes
        // Categories are only APPLIED to self-expenses in the UI
        await CategoryService.learnCategory('Valid Category');
        
        final suggestions = await CategoryService.getSuggestions('val');
        expect(suggestions.length, 1);
      });

      test('Trie is a global vocabulary - learns from multiple sources', () async {
        // Simulate learning from different transaction sources
        // Self expense
        await CategoryService.learnCategory('Groceries');
        // Friend lent transaction
        await CategoryService.learnCategory('Dinner with John');
        // Friend borrowed transaction  
        await CategoryService.learnCategory('Movie tickets');
        
        final all = await CategoryService.getAllNotes();
        expect(all.length, 3);
        
        // All should be searchable
        expect((await CategoryService.getSuggestions('gro')).length, 1);
        expect((await CategoryService.getSuggestions('din')).length, 1);
        expect((await CategoryService.getSuggestions('mov')).length, 1);
      });
    });

    group('Friend Transaction Learning', () {
      test('should learn from friend transaction notes', () async {
        // Simulating notes from friend transactions
        await CategoryService.learnCategory('Lunch with Mike');
        await CategoryService.learnCategory('Uber ride split');
        await CategoryService.learnCategory('Concert tickets');
        
        final all = await CategoryService.getAllNotes();
        expect(all.length, 3);
      });

      test('should provide suggestions from mixed history', () async {
        // Self expense notes
        await CategoryService.learnCategory('Groceries');
        await CategoryService.learnCategory('Gas station');
        
        // Friend transaction notes
        await CategoryService.learnCategory('Gym membership');
        await CategoryService.learnCategory('Group dinner');
        
        // Should find both self and friend notes
        final gSuggestions = await CategoryService.getSuggestions('g');
        expect(gSuggestions.length, 4);
        expect(gSuggestions.any((s) => s.toLowerCase() == 'groceries'), true);
        expect(gSuggestions.any((s) => s.toLowerCase() == 'gas station'), true);
        expect(gSuggestions.any((s) => s.toLowerCase() == 'gym membership'), true);
        expect(gSuggestions.any((s) => s.toLowerCase() == 'group dinner'), true);
      });

      test('junk filter still applies to friend notes', () async {
        // These should NOT be learned even if from friend transactions
        await CategoryService.learnCategory('');
        await CategoryService.learnCategory('no note');
        await CategoryService.learnCategory('--');
        await CategoryService.learnCategory('.');
        
        // Valid friend note
        await CategoryService.learnCategory('Birthday gift');
        
        final all = await CategoryService.getAllNotes();
        expect(all.length, 1);
        expect(all.first.normalizedName, 'birthday gift');
      });

      test('myshare pattern filtered even from friend transactions', () async {
        // Auto-generated split notes should be filtered
        await CategoryService.learnCategory('YOU(myshare)');
        await CategoryService.learnCategory('Pizza (my share)');
        await CategoryService.learnCategory('Dinner (myshare)');
        
        // Valid note
        await CategoryService.learnCategory('Pizza party');
        
        final all = await CategoryService.getAllNotes();
        expect(all.length, 1);
        expect(all.first.normalizedName, 'pizza party');
      });

      test('migration includes notes from all friends', () async {
        // Simulate migration with mixed transaction sources
        final allTransactions = [
          // Self expenses
          {'note': 'Groceries'},
          {'note': 'Electric bill'},
          // Friend 1 transactions
          {'note': 'Lunch at cafe'},
          {'note': 'Taxi fare'},
          // Friend 2 transactions
          {'note': 'Movie night'},
          {'note': 'no note'}, // Should be filtered
          // Split transactions with auto-generated suffix
          {'note': 'YOU(myshare)'}, // Should be filtered
        ];
        
        final count = await CategoryService.migrateExistingTransactions(() => allTransactions);
        expect(count, 5); // Only 5 valid notes
        
        final all = await CategoryService.getAllNotes();
        expect(all.length, 5);
      });

      test('frequency tracking works across all sources', () async {
        // Same note from different transaction sources
        await CategoryService.learnCategory('Coffee');
        await CategoryService.learnCategory('Coffee');
        await CategoryService.learnCategory('Coffee');
        
        final freq = await CategoryService.getFrequency('coffee');
        expect(freq, 3);
      });
    });

    group('Edge Cases', () {
      test('should handle unicode/special chars in valid notes', () {
        expect(CategoryService.isValidForLearning('Café'), true);
        expect(CategoryService.normalizeNote('Café'), 'café');
      });

      test('should handle very long valid notes', () {
        final longNote = 'A' * 100;
        expect(CategoryService.isValidForLearning(longNote), true);
      });

      test('should handle exactly 3 character note', () {
        expect(CategoryService.isValidForLearning('abc'), false); // 'abc' is in invalid list
        expect(CategoryService.isValidForLearning('xyz'), true);
        expect(CategoryService.normalizeNote('xyz'), 'xyz');
      });

      test('Trie handles special characters in prefix', () async {
        await CategoryService.learnCategory('Café Latte');
        
        final suggestions = await CategoryService.getSuggestions('café');
        expect(suggestions.length, 1);
      });
    });

    group('Diagnostics', () {
      test('getTrieDiagnostics returns correct info', () async {
        await CategoryService.learnCategory('Groceries');
        await CategoryService.learnCategory('Food');
        await CategoryService.learnCategory('Transport');
        
        // Create some Class B categories
        await CategoryService.createCategory('Shopping');
        await CategoryService.createCategory('Travel');
        
        final diagnostics = await CategoryService.getTrieDiagnostics();
        
        expect(diagnostics['noteCount'], 3);       // Class A notes
        expect(diagnostics['categoryCount'], 2);   // Class B categories
        expect(diagnostics['nodeCount'], greaterThan(0));
        expect(diagnostics['sampleNotes'], isNotEmpty);
        expect(diagnostics['isMigrated'], false); // Not migrated in test
      });

      test('Trie returns suggestions after learning', () async {
        // Simulate what happens when user types
        await CategoryService.learnCategory('Lunch with Mike');
        await CategoryService.learnCategory('Lunch at cafe');
        await CategoryService.learnCategory('Dinner party');
        
        // Typing "l" should return lunch suggestions
        final lSuggestions = await CategoryService.getSuggestions('l');
        expect(lSuggestions.length, 2);
        
        // Typing "lu" should narrow down
        final luSuggestions = await CategoryService.getSuggestions('lu');
        expect(luSuggestions.length, 2);
        
        // Typing "lunch w" should narrow more
        final lunchWSuggestions = await CategoryService.getSuggestions('lunch w');
        expect(lunchWSuggestions.length, 1);
        expect(lunchWSuggestions.first.toLowerCase(), 'lunch with mike');
      });

      test('Suggestions work for single character prefix', () async {
        await CategoryService.learnCategory('Movies');
        await CategoryService.learnCategory('Milk');
        await CategoryService.learnCategory('Medicine');
        
        final suggestions = await CategoryService.getSuggestions('m');
        expect(suggestions.length, 3);
      });
    });
  });
}
